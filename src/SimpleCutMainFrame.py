"""Subclass of MainFrame, which is generated by wxFormBuilder."""

from export.model import VideoFile
from controller.core import CoreController
import logging
import os
import subprocess
import sys
import threading
import time

import wx
from pymediainfo import MediaInfo

import meta
import SimpleCutPy
from command import concat_filter, merge_filestream_audio_channel
from message import ExportMessage, WorkStateEnum
from model import VideoSequenceModel


class FileDropTarget(wx.FileDropTarget):
    def __init__(self, target: "SimpleCutPyMainFrame"):
        wx.FileDropTarget.__init__(self)
        self.target = target

    def OnDropFiles(self, x, y, filenames):
        for file in filenames:
            filename, filepath = os.path.split(file)
            self.target.core_controller.add_file(filename, filepath)

        return True


# TODO: 重写配置的参数验证，建立物品类和导出配置 ExportConfig


# Implementing MainFrame
class SimpleCutPyMainFrame(SimpleCutPy.MainFrame):
    def __init__(self, parent=None):
        SimpleCutPy.MainFrame.__init__(self, parent)

        # 设置拖拽文件
        self.list_ctrl.SetDropTarget(FileDropTarget(self))

        self.first_selected_index = 0
        # self.item_list: list[dict] = []  # 列表是控件上的映射，列表的物品顺序就是控件上物品的顺序
        self.video_sequence: VideoSequenceModel = VideoSequenceModel()

        # list_ctrl 控件添加列
        self.list_ctrl.InsertColumn(0, "序号", width=40)
        self.list_ctrl.InsertColumn(1, "文件名", width=280)
        self.list_ctrl.InsertColumn(2, "开始时间", width=65)
        self.list_ctrl.InsertColumn(3, "结束时间", width=65)
        self.list_ctrl.InsertColumn(4, "文件路径", width=238)

        # 标记版本
        self.VersionText.SetLabelText(f"Simple Cut Py 版本号\n{meta.VERSION}")

        # Handlers for MainFrame events.

        # TODO: 参数初始化
        self.ExportBitCtrl.SetValue("6")

        # 线程字典
        self.working_thread: dict[str, threading.Thread] = {}

        self.core_controller = CoreController(self)

    def _bind_event(self):
        pass

    def on_add_file_button_click(self, event):
        # 文件选择对话框
        file_dlg = wx.FileDialog(self, "选择导入的文件", "", "", "*.mp4", wx.FD_OPEN)
        if file_dlg.ShowModal() == wx.ID_OK:
            # 导入文件
            filepath = file_dlg.GetPath()
            for filename in file_dlg.GetFilenames():
                self.core_controller.add_file(filename, filepath)

                logging.debug("导入文件：{}, {}".format(filename, filepath))

            self.update_video_sequence_view()

        file_dlg.Destroy()

    def list_ctrl_on_drop_files(self, event):
        files = event.GetFiles()

        # 防止拖空文件
        if len(files) <= 0:
            return

        logging.debug(f"拖拽文件：{files}")

        for full_file_path in files:
            filename, filepath = os.path.split(full_file_path)
            self.core_controller.add_file(filename, filepath)

        self.update_video_sequence_view()

    def on_remove_file_button_click(self, event):
        # 删除列表中的项
        target_idx = self.core_controller.first_select_index

        if target_idx <= -1:
            return  # 如果没有选中

        if target_idx >= self.core_controller.sequence_length():
            return  # 如果超出范围

        self.video_sequence.pop_video(target_idx)
        self.core_controller.remove_file(target_idx)

        self.update_video_sequence_view()

        # 选中 index
        self.list_ctrl.Select(target_idx)

    def on_move_up_file_button_click(self, event):
        idx = self.core_controller.first_select_index

        if idx == -1:
            return  # 如果没有选中

        if idx == 0:
            wx.MessageBox(
                "选中素材已置顶。", "错误", style=wx.YES_DEFAULT | wx.ICON_QUESTION
            )
            return  # 如果是第一个物品

        self.core_controller.swap_file(idx, idx - 1)

        self.update_video_sequence_view()

        self.list_ctrl.Select(idx, on=0)  # 取消原来的选中
        self.list_ctrl.Select(idx - 1)

    def on_move_down_file_button_click(self, event):
        idx = self.core_controller.first_select_index

        if idx == -1:
            return  # 如果没有选中

        if idx == self.list_ctrl.GetItemCount() - 1:
            wx.MessageBox(
                "选中素材在最末端。", "错误", style=wx.YES_DEFAULT | wx.ICON_QUESTION
            )
            return  # 如果是最后一个

        self.core_controller.swap_file(idx, idx + 1)

        self.update_video_sequence_view()

        # 选中转移
        self.list_ctrl.Select(idx, on=0)  # 取消原来的选中
        self.list_ctrl.Select(idx + 1)

    def on_export_button_click(self, event):
        # TODO: 加了码率设置的功能，别忘了测试
        # TODO: item list 重写

        # 从界面读取导出文件名、路径、码率
        export_name = self.ExportNameCtrl.GetValue()
        export_path = self.ExportPathCtrl.GetValue()
        export_mbps = self.ExportBitCtrl.GetValue()
        export_amix = self.AmixCheckBox.IsChecked()
        export_double_output = self.DoubleOutputBox.IsChecked()

        # 导出码率设置为空则使用 6 mbps
        if export_mbps == "":
            export_mbps = 6

        # 导出文件名为空则使用时间
        if export_name == "":
            export_name = str(time.strftime("No Title %Y.%m.%d - %H.%M.output.mp4"))

        # 导出路径不为空则更改导出目录
        if not export_path == "":
            # os.chdir(export_path)
            export_name = export_path + "/" + export_name
        else:
            # 默认使用第一个文件的目录
            path = os.path.dirname(self.video_sequence[0].path)
            export_name = path + "/" + export_name

        paths = [export_name]

        # 如果没有后缀 添加类型后缀
        if "." not in export_name:
            export_name += ".mp4"

        # 获取后缀
        path_without_suffix, suffix = os.path.splitext(export_name)

        if export_double_output:
            # 如果导出双倍输出，则给文件名添加后缀
            paths.append(path_without_suffix + "_WITHAMIX" + suffix)

        # 导出
        for it in paths:
            # 第一个输出文件使用用户设置的amix状态
            # 第二个输出文件（带_WITHAMIX后缀）强制使用amix=True
            if "_WITHAMIX" in it:
                # 对于带_WITHAMIX后缀的输出，强制使用多音轨合并
                t = threading.Thread(
                    target=self.export_video_file, args=(True, export_mbps, it)
                )
            else:
                # 使用用户设置的多音轨合并状态
                t = threading.Thread(
                    target=self.export_video_file, args=(False, export_mbps, it)
                )
            self.working_thread[it] = t
            t.start()

        self.ExportBtn.Disable()

        return

    def export_video_file(self, export_amix, export_mbps, export_name):
        # TODO: item list 重写
        # 导出命令

        # 获取ffmpeg路径 - 优先使用打包后的资源路径
        if getattr(sys, "frozen", False):
            # 打包后环境
            base_path = sys._MEIPASS  # type: ignore
        else:
            # 开发环境
            base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

        ffmpeg_path = os.path.join(base_path, "assets", "ffmpeg.exe")
        console_command = f'"{ffmpeg_path}" '
        filter_complex_string = "-filter_complex "
        filter_complex_filters: list[str] = []
        concat_inputs: list[str] = []
        for index, item in enumerate(self.video_sequence.video_list):
            no = index
            start_time = item.start_time
            end_time = item.end_time
            item_path = item.path

            # 开始、结束时间以及路径的命令行参数生成
            time_param = []
            if start_time != "":
                time_param.append(f"-ss {start_time}")
            if end_time != "":
                time_param.append(f"-to {end_time}")
            time_param.append(f'-i "{item_path}"')
            time_string = " ".join(time_param)

            console_command += time_string + " "

            # concat_inputs 的参数生成
            concat_inputs.append(f"{no}:v")

            media_info = MediaInfo.parse(item_path)
            audio_tracks_number = len(media_info.audio_tracks)
            if audio_tracks_number > 0 and export_amix:
                # 多音轨，合并
                # amix_filter
                filter_complex_filters.append(
                    merge_filestream_audio_channel(
                        f"{no}", audio_tracks_number, f"{no}a"
                    )
                )
                concat_inputs.append(f"{no}a")
            else:
                # 单音轨
                concat_inputs.append(f"{no}:a")
        # 使用 concat 滤镜
        concat_string = concat_filter(concat_inputs, "v", "a")
        filter_complex_filters.append(concat_string)
        # 拼接 filter_complex 命令行参数，拼接滤镜
        console_command += (
            filter_complex_string + f'"{";".join(filter_complex_filters)}"'
        )
        console_command += ' -map "[v]" -map "[a]"'
        # 拼接全指令
        if os.path.split(export_name)[1] == "":
            export_name += ".mp4"

        console_command += f' -b:v {export_mbps}M "{export_name}"'
        logging.info(f"导出命令：{console_command}")

        # 执行命令
        try:
            subprocess.run(
                console_command,
                shell=False,
                check=True,
                creationflags=subprocess.CREATE_NO_WINDOW,
            )

            # 完成命令，发送事件
            wx.CallAfter(
                self.on_export_done,
                ExportMessage(WorkStateEnum.SUCCESS, "导出完成", export_name),
            )
        except subprocess.CalledProcessError as e:
            # 导出失败，发送事件
            wx.CallAfter(self.on_export_done, ExportMessage(WorkStateEnum.FAIL, e))

    def on_open_project_website_button_click(self, event):
        # TODO: Implement ProjectWebBtnOnClick
        pass

    def on_clear_all_button_click(self, event):
        self.core_controller.clear_all_files()
        logging.debug(f"clear all video: {self.video_sequence.video_list}")
        self.update_video_sequence_view()

    def on_start_time_ctrl_text(self, event):
        """修改开始时间输入框的时候修改itemlist的start_time"""
        index = self.core_controller.first_select_index

        value = self.StartTimeCtrl.GetValue()

        # 尝试更新数据
        try:
            videofile = self.core_controller.get_file(index)
            videofile.start_time = value
        except ValueError as e:
            logging.error(f"Set Start Time Error: {e}")
            return

        self.update_video_file_view(videofile)

    def on_end_time_ctrl_text(self, event):
        """修改结束时间输入框的时候修改itemlist的end_time"""
        index = self.core_controller.first_select_index

        value = self.EndTimeCtrl.GetValue()

        # 尝试更新数据
        try:
            videofile = self.core_controller.get_file(index)
            videofile.end_time = value
        except ValueError as e:
            logging.error(f"Set End Time Error: {e}")
            return

        self.update_video_file_view(videofile)

    def on_list_item_selected(self, event):
        index = self.list_ctrl.GetFirstSelected()
        self.core_controller.first_select_index = index

        # 获取选中的物品时间，同步到输入框
        self.StartTimeCtrl.SetValue(self.core_controller.get_file(index).start_time)
        self.EndTimeCtrl.SetValue(self.core_controller.get_file(index).end_time)

        logging.debug(
            f"Selected Item Index: {index}, \
                    Selected Item no: {self.core_controller.get_file(index)}"
        )

    def on_export_done(self, msg: ExportMessage):
        logging.debug(f"Export Done: {msg}")
        if msg.state == WorkStateEnum.SUCCESS:
            wx.MessageBox("导出成功", "提示", wx.OK | wx.ICON_INFORMATION)
            if msg.export_name != "":
                self.working_thread.pop(msg.export_name)
        elif msg.state == WorkStateEnum.FAIL:
            logging.error(f"Export Error: {msg.message}")
            wx.MessageBox("导出失败", "提示", wx.OK | wx.ICON_INFORMATION)

        if len(self.working_thread) == 0:
            self.ExportBtn.Enable()

        return

    def update_video_file_view(self, file: VideoFile):
        """将 VideoFile 载入到 列表item上

        Args:
            file (VideoFile): 要载入的视频文件
            index (int): 要载入的列表项索引
        """
        index = file.no - 1
        self.list_ctrl.SetItem(index, 0, str(index))
        self.list_ctrl.SetItem(index, 1, file.file_name)
        self.list_ctrl.SetItem(index, 2, file.start_time)
        self.list_ctrl.SetItem(index, 3, file.end_time)
        self.list_ctrl.SetItem(index, 4, file.file_path)

    def update_video_sequence_view(self, index=-1) -> None:
        """更新视频序列视图

        Args:
            index (int, optional): 要更新的视频序列索引. 默认-1表示更新所有.
        """
        sequence = self.core_controller.task.video_sequence.get_video_list()
        if index == -1:
            for item in sequence:
                self.update_video_file_view(item)
            return

        self.update_video_file_view(sequence[index])


if __name__ == "__main__":
    App = wx.App()
    mainFrame = SimpleCutPyMainFrame(None)
    mainFrame.Show(True)
    App.MainLoop()
